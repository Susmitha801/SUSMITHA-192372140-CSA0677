code:
def nearestZero(mat):
    m, n = len(mat), len(mat[0])
    MAX = float('inf')
    dist = [[MAX] * n for _ in range(m)]
    queue = []
    for i in range(m):
        for j in range(n):
            if mat[i][j] == 0:
                dist[i][j] = 0
                queue.append((i, j))
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    while queue:
        i, j = queue.pop(0)
        for dx, dy in directions:
            x, y = i + dx, j + dy
            if 0 <= x < m and 0 <= y < n and dist[x][y] > dist[i][j] + 1:
                dist[x][y] = dist[i][j] + 1
                queue.append((x, y))
    return dist
mat = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]
result = nearestZero(mat)
for row in result:
    print(row)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
32.

code:
def minOperations(arr1, arr2):
    arr2.sort()  
    n = len(arr1)
    dp = [float('inf')] * n
    dp[0] = 0
    for i in range(1, n):
        for j in range(i):
            if arr1[j] < arr1[i]:
                dp[i] = min(dp[i], dp[j])
            else:
                k = bisect_left(arr2, arr1[j] + 1)
                if k < len(arr2):
                    dp[i] = min(dp[i], dp[j] + 1)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
33.

code:
def min_repeats(a, b):
    repeats = 1
    current = a
    while len(current) <= len(a) + len(b):
        if b in current:
            return repeats
        current += a
        repeats += 1
    return -1
a = "abcd"
b = "cdabcdab"
result = min_repeats(a, b)
print(result)  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
34.

code:
def getMissingNo(arr, n):
    N = n + 1
    total_sum = N * (N + 1) // 2
    array_sum = sum(arr)
    return total_sum - array_sum
arr = [1, 2, 3, 5]
n = len(arr)
missing_number = getMissingNo(arr, n)
print(missing_number)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
35.

code:
def largestLocal(grid):
    n = len(grid)
    maxLocal = [[0] * (n - 2) for _ in range(n - 2)]
    for i in range(n - 2):
        for j in range(n - 2):
            # Initialize the maximum value for the current 3x3 submatrix
            max_val = float('-inf')
            for x in range(i, i + 3):
                for y in range(j, j + 3):
                    max_val = max(max_val, grid[x][y])
            maxLocal[i][j] = max_val
    return maxLocal
grid1 = [
    [9, 9, 8, 1],
    [5, 6, 2, 6],
    [8, 2, 6, 4],
    [6, 2, 2, 2]
]
result1 = largestLocal(grid1)
print(result1)  
grid2 = [
    [1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1],
    [1, 1, 2, 1, 1],
    [1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1]
]
result2 = largestLocal(grid2)
print(result2)  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
36
.
code:
def count_prefix_strings(words, pref):
    count = 0
    for word in words:
        if word.startswith(pref):
            count += 1
    return count
words = ["pay", "attention", "practice", "attend"]
pref = "at"
print(count_prefix_strings(words, pref))
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
37

code:
def set_zeroes(matrix):
    rows, cols = len(matrix), len(matrix[0])
    first_row_has_zero = any(matrix[0][j] == 0 for j in range(cols))
    first_col_has_zero = any(matrix[i][0] == 0 for i in range(rows))
    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][j] == 0:
                matrix[i][0] = 0
                matrix[0][j] = 0
    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0
    if first_row_has_zero:
        for j in range(cols):
            matrix[0][j] = 0
    if first_col_has_zero:
        for i in range(rows):
            matrix[i][0] = 0
matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]
set_zeroes(matrix)
print(matrix)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
38

code:
def find_intersection(nums1, nums2):
    set1 = set(nums1)
    set2 = set(nums2)
    intersection = set1 & set2
    result = list(intersection)
    return result
nums1 = [1, 2, 2, 1]
nums2 = [2, 2]
print(find_intersection(nums1, nums2))
nums3 = [4, 9, 5]
nums4 = [9, 4, 9, 8, 4]
print(find_intersection(nums3, nums4))
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
39

code:
MOD = 10**9 + 7
def count_good_strings(n, s1, s2, evil):
    def dfs(pos, prefix, evil_seen):
        if pos == n:
            return 1
        if (pos, prefix, evil_seen) in memo:
            return memo[(pos, prefix, evil_seen)]
        count = 0
        for char in range(ord('a'), ord('z') + 1):
            next_prefix = prefix + chr(char)
            if s1 <= next_prefix <= s2:
                next_evil_seen = evil_seen or (evil in next_prefix)
                if not next_evil_seen:
                    count = (count + dfs(pos + 1, next_prefix, next_evil_seen)) % MOD
        memo[(pos, prefix, evil_seen)] = count
        return count
    memo = {}
    return dfs(0, "", False)
n = 2
s1 = "aa"
s2 = "da"
evil = "b"
print(count_good_strings(n, s1, s2, evil)) 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
40

code:
def transpose_matrix(matrix):
    rows, cols = len(matrix), len(matrix[0])
    transposed = [[0] * rows for _ in range(cols)]
    for i in range(rows):
        for j in range(cols):
            transposed[j][i] = matrix[i][j]
    return transposed
matrix1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
result1 = transpose_matrix(matrix1)
print(result1)
matrix2 = [[1, 2, 3], [4, 5, 6]]
result2 = transpose_matrix(matrix2)
print(result2) 
